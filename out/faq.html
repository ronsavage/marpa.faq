<!DOCTYPE html>
<html><head>
<title>The Marpa FAQ</title>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-combined.min.css" rel="stylesheet">
<link href="style.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div class="row">
        <div class="offset2 span8">
<h1>The Marpa FAQ</h1>

<h2>On-line docs</h2>

<p><a href="http://savage.net.au/Perl-modules/html/marpa.faq/">The Marpa FAQ</a></p>

<p><a href="http://savage.net.au/Perl-modules/html/marpa.papers/">The Marpa Papers</a></p>

<h2>Github repos</h2>

<p><a href="https://github.com/ronsavage/marpa.faq.git">The Marpa FAQ repo</a></p>

<p><a href="https://github.com/ronsavage/marpa.papers.git">The Marpa Papers repo</a></p>

<h2>Table of Contents grouped by Topic</h2>

<h2>About Marpa</h2>

<ul>
<li><a href="#q102">102 What is Libmarpa?</a></li>
</ul>

<h2>Error Messages</h2>

<ul>
<li><a href="#q1">1 Error: Parse failed. value() called when recognizer is not in tree mode</a></li>
<li><a href="#q2">2 Error: A lexeme in G1 is not a lexeme in any of the lexers</a></li>
<li><a href="#q3">3 Error: A lexeme in lexer L0 is not a lexeme in G1</a></li>
<li><a href="#q4">4 Error: Marpa exited at (line, column) = ($line, $column) within the input string</a></li>
<li><a href="#q5">5 Error: No lexeme found at line 1, column 5</a></li>
<li><a href="#q6">6 Error: An L0 lexeme cannot appear on the RHS of an L0 rule</a></li>
</ul>

<h2>Problems</h2>

<ul>
<li><a href="#q107">107 Why doesn't my ambiguous grammar return more than 1 parse tree?</a></li>
<li><a href="#q117">117 Why does using '+' or '*' in a rule only work sometimes?</a></li>
<li><a href="#q118">118 Can a lexeme have length == 0?</a></li>
<li><a href="#q142">142 I used a precedenced statement for my expression, so why did my parse come out ambiguous anyway?</a></li>
<li><a href="#q149">149 The Libmarpa API and missing valuator steps</a></li>
</ul>

<h2>Tricks and techniques</h2>

<ul>
<li><a href="#q108">108 How do I implement disambiguation logic?</a></li>
<li><a href="#q110">110 How do I parse comments?</a></li>
<li><a href="#q111">111 How do I parse numbers?</a></li>
<li><a href="#q112">112 How do I represent choice in the grammar?</a></li>
<li><a href="#q113">113 Is there any other way of representing choice?</a></li>
<li><a href="#q114">114 What's the difference between '|' and '||' in grammar definitions?</a></li>
<li><a href="#q115">115 What does it mean to hide (mask) tokens?</a></li>
<li><a href="#q116">116 How do I implement recursion in a grammar?</a></li>
<li><a href="#q119">119 How do I find out where I am within the input stream?</a></li>
<li><a href="#q120">120 How do I find out which rule applies at some point in the input stream (e.g. during a pause)?</a></li>
<li><a href="#q121">121 What is the meaning of the line number in a Marpa error message?</a></li>
<li><a href="#q122">122 Can I switch grammars during a parse?</a></li>
<li><a href="#q123">123 Where is Ruby Slippers parsing documented?</a></li>
<li><a href="#q124">124 Where can I find code using Ruby Slippers?</a></li>
<li><a href="#q125">125 How do I associate an action class with my grammar?</a></li>
<li><a href="#q126">126 Declaring an Action Class</a></li>
<li><a href="#q127">127 Where can I find code using events?</a></li>
<li><a href="#q128">128 Where can I find code which builds its grammar on-the-fly?</a></li>
<li><a href="#q133">133 What grammar do I use when eol ("\n", new-line) is significant?</a></li>
<li><a href="#q134">134 When I use the case-insensitive suffix ':i' my program dies</a></li>
<li><a href="#q135">135 When do I use actions and when do I use events?</a></li>
<li><a href="#q136">136 How does Marpa pass parameters to action subs?</a></li>
<li><a href="#q144">144 How do I use external parsing?</a></li>
<li><a href="#q145">145 How do I distinguish between identifiers and keywords?</a></li>
<li><a href="#q146">146 How do I write the BNF to specify exceptions to a pattern, or the complement of a pattern?</a></li>
<li><a href="#q147">147 How do I write the BNF when the first token is optional?</a></li>
<li><a href="#q148">148 Is there a tabular view of the DSL?</a></li>
<li><a href="#q151">151 How can I trace what the L0 parser is doing?</a></li>
<li><a href="#q152">152 How do I define lexemes for identifiers where the 1st char is from a subset of the other 
chars?</a></li>
<li><a href="#q139">139 What is the difference between prediction events and pre-lexeme events?</a></li>
<li><a href="#q140">140 Precedence, associativity, priority and rank</a></li>
</ul>

<h2>Details on how Marpa works</h2>

<ul>
<li><a href="#q103">103 Is Marpa deterministic?</a></li>
<li><a href="#q104">104 What is the difference between ambiguity and non-determinism?</a></li>
<li><a href="#q109">109 What is the meaning of L0 and G1?</a></li>
<li><a href="#q137">137 SPPF parsing</a></li>
<li><a href="#q138">138 Parse exhaustion</a></li>
</ul>

<h2>Links and resources</h2>

<ul>
<li><a href="#q101">101 Where do I go for help?</a></li>
<li><a href="#q129">129 Other Resources</a></li>
<li><a href="#q130">130 Papers on Parsing Theory</a></li>
<li><a href="#q131">131 Are there C/Perl/Rust/etc bindings for libmarpa?</a></li>
<li><a href="#q132">132 What are the Marpa Papers?</a></li>
<li><a href="#q141">141 I want to write my own version of the Marpa/Earley/Leo algorithm in language X. What's the best way to proceed?</a></li>
<li><a href="#q143">143 How do I contribute to this FAQ?</a></li>
<li><a href="#q150">150 Are there any comparisons of Marpa against other parsers for speed and practicality?</a></li>
<li><a href="#q153">153 Are there any on-line tools for testing grammars?</a></li>
<li><a href="#q154">154 What do I do when the IRC logbot stops?</a></li>
<li><a href="#q155">155 Where can I find a timeline (history) of parsing?</a></li>
</ul>

<h2>Answers grouped by Topic</h2>

<h2>About Marpa</h2>

<p><a name = 'q102'></a></p>

<h2>102 What is Libmarpa?</h2>

<p>Libmarpa is the core Marpa library, written in C, which implements the Marpa parse engine - the Marpa algorithm itself.
It is low-level, but it is documented and can be installed and used separately.</p>

<p><a href="https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html">Homepage</a>.</p>

<p><a href="http://jeffreykegler.github.io/Marpa-web-site/libmarpa_api/latest/index.html">Index of Terms</a>.</p>

<p><a href="https://jeffreykegler.github.io/Marpa-web-site/libmarpa_api/cpan_indexed/index.html">Formal docs</a>.</p>

<h2>Error Messages</h2>

<p><a name = 'q1'></a></p>

<h2>1 Error: Parse failed. value() called when recognizer is not in tree mode</h2>

<p>The culprit is Marpa::R2::Scanless::R's
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#ambiguous">ambiguous()</a> method.</p>

<p>Forest mode is something most users don't care about.
It is used for Marpa's Abstract Syntax Forests.
See <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/ASF.pod">Marpa::R2::ASF</a> if you want to know
more about those. The usual mode is 'tree mode', and most of Marpa's calls,
such as value(), require you to be in 'tree mode'.</p>

<p>ambiguous() uses forest mode to print a detailed description of the ambiguity.
(By the way, try getting <em>that</em> out of another parser.)
And ambiguous() leaves you in forest mode, which means you cannot do much of
the usual processing, such as calling value().
So how do you get around this problem?</p>

<p>There are two ways, depending on what you are trying to do.
Most often, you regard an ambiguity in your parse as an error,
so you want to print helpful message and abend if the parse
is ambiguous,
and go on to do normal stuff if it is not.
What you should do in this case is call
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#ambiguity_metric">ambiguity_metric()</a>
first.
ambiguity_metric()
returns 1 for an unambiguous parse and 2+ for an ambiguous parse. Errors return something &lt;= 0.
And ambiguity_metric() does <em>not</em> put you into forest mode. See also <a href='#q4'>Q4 Error message: Marpa exited...</a>.</p>

<p>Less often, you want to both print out a message describing the parse's ambiguity,
and then go on to deal with it in 'tree mode'.
In this case, you can call the
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#series_restart">series_restart()</a> method.
series_restart() puts you back into 'tree mode'.</p>

<p>And here is some code copied directly from V 2 of
<a href="https://metacpan.org/release/Genealogy-Gedcom-Date">Genealogy::Gedcom::Date</a>. The method decode_result()
is listed below, and Dumper() is from
<a href="https://metacpan.org/release/Data-Dumper-Concise">Data::Dumper::Concise</a>. Of course the calling code
checks that the return from ambiguity_metric() is > 1:</p>

<pre class="prettyprint linenums"><code>    my($count) = 0;

    while (my $value = $self -&gt; recce -&gt; value)
    {
        $value = $self -&gt; decode_result($$value); # Returns an arrayref, hence the 'for' below.

        $self -&gt; log(debug =&gt; "Solution @{[++$count]}: \n" . Dumper($_) ) for @$value;
    }
</code></pre>

<p>For more on ambiguity_metric(), see <a href='#q4'>Q4</a>.</p>

<p>But remember, to handle ambiguity, you don't need to use this code. You can take a completely different
route with <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/ASF.pod">Marpa::R2::ASF</a>.</p>

<p>And there are still more choices: Leave the ambiguity as an error, re-work the grammar,
or perhaps switch to events attached to lexemes.</p>

<p>In the latter case, if 2 or more events are fired by the same lexeme you can write code
which chooses 1 of those events, and you then tell Marpa to continue with that choice. For code using
this technique, see <a href="https://metacpan.org/release/GraphViz2-Marpa">GraphViz2::Marpa</a>,
<a href="https://metacpan.org/release/Text-Balanced-Marpa">Text::Balanced::Marpa</a> or
<a href="https://metacpan.org/release/Text-Delimited-Marpa">Text::Delimited::Marpa</a>.</p>

<p><a name = 'q2'></a></p>

<h2>2 Error: A lexeme in G1 is not a lexeme in any of the lexers</h2>

<p>Marpa automatically determines which symbols are 'lexemes'. To do this, it checks for all the
symbols that the G1 grammar considers to be lexemes, and all the symbols that the L0 grammar
considers to be lexemes. It requires these two lists to match.</p>

<p>Lexemes in G1 are defined in rules using := and lexemes in L0 are defined by rules using ~.</p>

<p>A symbol is a G1 lexeme if it appears on the RHS of a G1 rule, but never appears on the LHS of
any G1 rule. A symbol is an L0 lexeme if it appears on the LHS of an L0 rule, but never appears
on the RHS of any L0 rule.</p>

<p>See also <a href='#q6'>Q 6</a>.</p>

<p><a name = 'q3'></a></p>

<h2>3 Error: A lexeme in lexer L0 is not a lexeme in G1</h2>

<p>See <a href='#q2'>the previous FAQ question</a>.</p>

<p><a name = 'q4'></a></p>

<h2>4 Error message: Marpa exited at (line, column) = ($line, $column) within the input string</h2>

<p>In the module <a href="https://metacpan.org/release/Genealogy-Gedcom-Date">Genealogy::Gedcom::Date</a>,
this text is part of the error message when a call to Marpa ambiguity_metric() returned a value &lt;= 0.</p>

<p>Consider the possibility that the parse ends without a successful parse, but the input is the
prefix of some input that can lead to a successful parse.</p>

<p>Marpa is not reporting a problem during the read(), because you can add more to the input string,
and Marpa does not know that you do not plan to do this.</p>

<p><a name = 'q5'></a></p>

<h2>5 Error in SLIF parse: No lexeme found at line 1, column 5</h2>

<p>The full error text will look like:</p>

<pre class="prettyprint linenums"><code>Error in SLIF parse: No lexeme found at line 1, column 5
* String before error: (?^:
* The error was at line 1, column 5, and at character 0x0029 ')', ...
* here: )
</code></pre>

<p>The part which says 'No lexeme found' means no lexeme <em>according to your grammar</em>. The actual
character found is listed here as ')', but your BNF does not define that character as being a lexeme
in that context.</p>

<p><a name = 'q6'></a></p>

<h2>6 Error: An L0 lexeme cannot appear on the RHS of an L0 rule</h2>

<p>Consider these rules, which define lexemes in L0 (they are in L0 because ~ is used):</p>

<pre class="prettyprint linenums"><code>X ~ Y
Z ~ X
Y ~ 'y'
</code></pre>

<p>The usage of X in Z ~ X will trigger the error.</p>

<p>This means a lexeme in L0 (defined as is X by the tilde in the rule X ~ Y) cannot be used to
define another lexeme (Z as in Z ~ X). The first occurrance of X is on the LHS of the first rule
and the second occurrance of X is on the RHS of the second rule. You can't do that in Marpa::R2.</p>

<p>So the error message can be read as saying (and should say):</p>

<p>'An L0 lexeme (X in the rule X ~ Y) cannot appear on the RHS of another L0 rule (Z ~ X)'.</p>

<p>See also <a href='#q2'>Q 2</a>.</p>

<h2>Problems</h2>

<p><a name = 'q107'></a></p>

<h2>107 Why doesn't my ambiguous grammar return more than 1 parse tree?</h2>

<p>Probably because your grammar includes</p>

<pre class="prettyprint linenums"><code>lexeme default = latm =&gt; 1 # Active the Longest Acceptable Token Match option.
</code></pre>

<p>Try commenting that line out after, perhaps, re-reading the previous question's answer.</p>

<p>See also the questions 8 and 9.</p>

<p><a name = 'q101'></a></p>

<h2>101 Where do I go for help?</h2>

<p>The IRC channel may get the quickest response: irc.freenode.net#marpa.</p>

<p>The <a href="https://manpages.org/">website manpages.org</a> has good docs on the theoretical details.
Just type marpa into the search box and hit Enter.</p>

<p><a href="https://groups.google.com/forum/#!forum/marpa-parser">The Google Group</a> has message threading,
and so is good for complex or extended discussions.</p>

<p><a href="http://savage.net.au/Marpa.html">Marpa's homepage</a>.</p>

<p><a name = 'q103'></a></p>

<h2>103 Is Marpa deterministic?</h2>

<p>No. Marpa is non-deterministic, unlike traditional parsers. Marpa tries everything, all at once.</p>

<p>This may take some getting used to, in the sense that probably what you're used to is a deterministic parse.</p>

<p>If two alternatives (in a prioritized rule say, separated by '|' or '||') happen to match some source,
Marpa produces 2 parse trees.</p>

<p>The parser, then, catches all ambiguities, but the SLIF lexer does <em>not</em>, whether it is LTM or LATM.
LTM is Longest Token Match, and LATM is Longest Acceptable Token Match.</p>

<p>The SLIF lexer does a longest tokens (plural) match. So it does recognize ambiguous tokens if they are longest tokens.</p>

<p>Ambiguous tokens which are shorter than the match one (whether the discipline is LATM or LTM) are ignored
by the lexer.</p>

<p>Consequently, this means the ambiguous matched tokens must be all the same length.</p>

<p>See also the next 2 questions.</p>

<p><a name = 'q104'></a></p>

<h2>104 What is the difference between ambiguity and non-determinism?</h2>

<p>Ambiguous means there is more than one parse.</p>

<p>Non-deterministic means that, in the course of discovering the parse or parses, multiple paths may
be pursued at the same time.</p>

<p>A deterministic parser must always produce an unambiguous parse, if only by ignoring the other
alternatives, as in PEG.</p>

<p>A non-deterministic parser, like Marpa, can produce both ambiguous and unambiguous parses.</p>

<p><a href="http://irclog.perlgeek.de/marpa/2016-10-07#i_13360238">Example code</a>.</p>

<p><a name = 'q108'></a></p>

<h2>108 How do I implement disambiguation logic?</h2>

<p>See under <a href="https://metacpan.org/module/Marpa::R2::Semantics#Bailing-out-of-parse-evaluation">Bailing-out-of-parse-evaluation in Marpa::R2::Semantics</a>,
for how to short-circuit semantic analysis.</p>

<p>See also <a href="https://gist.github.com/dginev/6419166">this gist</a>.</p>

<p>See also the previous and next questions.</p>

<p><a name = 'q109'></a></p>

<h2>109 What is the meaning of L0 and G1?</h2>

<p>L0 defines exactly what tokens are acceptable in the input stream. So, these are the rules defining the
syntax of the tokens, but not the syntax of how these tokens can be combined. G1 defines the structure of
the language - the ways in which the tokens can be combined. In other words, G1 is structural and therefore
a 'parser' in the strictest sense, and L0 is its lexer. ('L' for lexer.)</p>

<p>One distinction between G1 and L0 is very important in designing a grammar/lexer combination: G1 rules have
a semantics. L0 rules do <em>not</em>.</p>

<p>L0 and G1 discussed in <a href="https://metacpan.org/module/Marpa::R2::Scanless::DSL">Marpa::R2::Scanless::DSL</a>,
and, very briefly, in <a href="https://metacpan.org/module/Marpa::R2::Semantics">Marpa::R2::Semantics</a>. In both
cases, search for 'L0'.</p>

<p><a name = 'q110'></a></p>

<h2>110 How do I parse comments?</h2>

<p><a href="https://metacpan.org/module/GraphViz2::Marpa">GraphViz2::Marpa</a> implements comment skipping for C
and C++ comments, and for #-prefix style comments. Search the source of Marpa.pm for
'C style comment', 'Cplusplus style comment' and 'hash style comment'.</p>

<p><a name = 'q111'></a></p>

<h2>111 How do I parse numbers?</h2>

<p>Chapter 2 of <a href="http://marpa-guide.github.io/">Peter Stuifzand's Marpa Guide</a> discusses this issue at length
And if you fork that project on github, you'll find the directory examples/ contains about a dozen sample programs.</p>

<p>Alternately, download <a href="https://metacpan.org/release/MarpaX-Languages-SVG-Parser">MarpaX::Languages::SVG::Parser</a>,
which contains similar logic (in data/*.bnf). Further, this latter distro includes sample code (float.pl and number.pl)
in the scripts/ directory. The last-named script includes grammars for binary, octal and hex numbers which I did
not need in the SVG parser.</p>

<p><a name = 'q112'></a></p>

<h2>112 How do I represent choice in the grammar?</h2>

<p>Briefly, use '|'. Sample code from the above named module (data/d.bnf):</p>

<pre class="prettyprint linenums"><code>coordinate  ::= float      action =&gt; float
                | integer  action =&gt; integer
</code></pre>

<p>Also note that '||' is available to control the relative priorities of the alternatives.</p>

<p>This issue is expanded upon in the next 2 items in this FAQ.</p>

<p><a name = 'q113'></a></p>

<h2>113 Is there any other way of representing choice?</h2>

<p>Sure. Consider these L0 rules (also from data/d.bnf):</p>

<pre class="prettyprint linenums"><code>sign_maybe  ~ [+-]
sign_maybe  ~

digit       ~ [0-9]
digit_any   ~ digit*
digit_many  ~ digit+

E           ~ [Ee] sign_maybe digit_many
E_maybe     ~ E
E_maybe     ~

:lexeme     ~ float
float       ~ sign_maybe digit_many E
              | sign_maybe digit_any '.' digit_many E_maybe
              | sign_maybe digit_many '.' E_maybe
              | sign_maybe non_zero digit_any
</code></pre>

<p>This is saying:</p>

<ul>
<li><p>The sign is optional after E or e (sign_maybe)</p></li>
<li><p>The E is optional (E_maybe)</p></li>
<li><p>The sign is optional before a digit (the first alternative for 'float')</p></li>
<li><p>And so on</p></li>
</ul>

<p><a name = 'q114'></a></p>

<h2>114 What's the difference between '|' and '||' in grammar definitions?</h2>

<p>'|' expresses a simple alternative, while '||' separates alternatives at different levels of precedence. For example:</p>

<pre class="prettyprint linenums"><code>E ::=    E '*' E
      |  E '/' E
      || E '+' E
      |  E '-' E
</code></pre>

<p>This describes syntax for a simple 4-operation calculator, where multiplication and division take precedence over
addition and subtraction.</p>

<p>This construct forces alternatives before the '||' to have higher precedence than the alternatives after that token.</p>

<p>Each of the alternatives separated by '|' are at the same precedence.</p>

<p>In Mark Dominus's 'Higher-Order Perl' book, he describes how he handles precedence in his recursive descent parsers
for a similar calculator, beginning on p. 394. This is a good description of how the same situation would be handled
with pre-Marpa techniques.</p>

<p>If precedence is not an issue for you, just use single bar alternation ('|').</p>

<p>Note also that Marpa supports a 'priority' adverb, discussed in the
<a href="https://metacpan.org/module/Marpa::R2::Scanless::DSL">Marpa::R2::Scanless::DSL</a> docs mentioned above.</p>

<p><a name = 'q115'></a></p>

<h2>115 What does it mean to hide (mask) tokens?</h2>

<p>It's possible to design a grammar such that we can say certain tokens are hidden. This is discussed under
<a href="https://metacpan.org/module/Marpa::R2::Scanless::DSL#RHS-alternatives">RHS-alternatives in Marpa::R2::Scanless::DSL</a>.</p>

<p>Here is an example (from <a href="https://metacpan.org/module/MarpaX::Languages::Dash">MarpaX::Languages::Dash</a>):</p>

<pre class="prettyprint linenums"><code>node_definition  ::= node_statement
                 | node_statement graph_definition

node_statement   ::= node_name
                 | node_name attribute_definition
                 | node_statement (',') node_statement

node_name        ::= start_node end_node

:lexeme          ~ start_node  pause =&gt; before  event =&gt; start_node
start_node       ~ '['

:lexeme          ~ end_node
end_node         ~ ']'
</code></pre>

<p>The comma is hidden. But what does this mean, exactly?</p>

<p>It means the comma may appear in the input stream (in this context), but I am not interested in it. So, Marpa will not
return this token to me when an action is called. It has become invisible to the semantics.</p>

<p>Semantics are documented in <a href="https://metacpan.org/module/Marpa::R2::Semantics">Marpa::R2::Semantics</a>.</p>

<p>Close study of the above grammar will show that another path is possible thru the grammar, in the case of
2 nodes side-by-side (i.e. without a comma between them). Thus the grammar accepts both these input streams
as valid:</p>

<pre class="prettyprint linenums"><code>Stream 1: [node.a], [node.b]
Stream 2: [node.a]  [node.b]
</code></pre>

<p>Hence, from the end-user's viewpoint, the comma is defined - at least in this particular grammar - to be optional.</p>

<p><a name = 'q116'></a></p>

<h2>116 How do I implement recursion in a grammar?</h2>

<p>See the next item.</p>

<p><a name = 'q117'></a></p>

<h2>117 Why does using '+' or '*' in a rule only work sometimes?</h2>

<p>I assume you're referring to cases like this:</p>

<p>Case 1 (fails):</p>

<pre class="prettyprint linenums"><code>node_definition  ::= node_statement+
                 | node_statement graph_definition
</code></pre>

<p>Case 2 (succeeds):</p>

<pre class="prettyprint linenums"><code>coordinate_list  ::= coordinate+
</code></pre>

<p>Case 3 (succeeds):</p>

<pre class="prettyprint linenums"><code>whitespace       ~ [\s]+
</code></pre>

<p>Briefly, quantified rules (here, using the '+'), are only allowed when the right-hand side contains a single
alternative. Thus case 1 fails due to the combination of '+' and '|'.</p>

<p>This is documented under <a href="https://metacpan.org/module/Marpa::R2::Scanless::DSL#Quantified-rule">'Quantified rule' in Marpa::R2::Scanless::DSL</a>.</p>

<p>So we must re-write rule 1 (with some context):</p>

<pre class="prettyprint linenums"><code>graph_definition  ::= node_definition
                  | edge_definition
                  | subgraph_definition

node_definition  ::= node_statement
                 | node_statement graph_definition

node_statement   ::= node_name
                 | node_name attribute_definition
                 | node_statement (',') node_statement
</code></pre>

<p>Now the rule 'node_definition ::= node_statement' allows a node definition to consist of a single node statement.</p>

<p>And the alternative (via the '|') 'node_definition ::= node_statement graph_definition' allows a node
definition to consist of a node statement followed by a graph definition, which just happens to include the line
'graph_definition ::= node_definition'!</p>

<p>So we've managed to write the grammar using indirect recursion, thus allowing an indefinite list of node
definitions to follow one another. And the last rule allows the input stream to separate them with commas as
well as the usual spaces.</p>

<p>In other words: Why does the SLIF require quantifiers to be separate statements?</p>

<p>It's different from regular expressions, which everyone is accustomed to, and seems awkward.</p>

<p>The reason is that, with a parser, you expect to attach a semantics to all the rules -
with regular expressions where is no such expectation.</p>

<p>So if Marpa allowed ' A ::= B+ (C | D) exp*', how would you specify how the arguments are
passed to the semantics?</p>

<p>If just as a list, they have to be re-parsed all over again.</p>

<p>This problem can be solved, but the easiest way around it is to write it out as separate
statements, with the quantifiers by themselves, and the semantics can then be attached to
the statements.</p>

<p><a name = 'q118'></a></p>

<h2>118 Can a lexeme have length == 0?</h2>

<p>No.</p>

<p>Marpa allows L0 rules that might be zero-length (for example, 'baZ ~ [Z]*') on the idea that it might be convenient
to write them that way. But no zero-length lexeme will ever be accepted as a result of such rules.</p>

<p>If you think out the conceptual issues, you might see nulled lexemes are 'fraught' with them. At any given point,
which null lexemes should you recognize? And how many of them? A parser could guess what you really mean here, but
to my (Jeffrey's) mind it is just as well to force you to be explicit on this issue.</p>

<p>Note: I (Ron) think Jeffrey uses pseudo in the name 'nulled pseudo-lexeme' because, being effectively of 0 length,
they can't actually be lexemes.</p>

<p>For sample code which shows a way of handling such an issue see
<a href="http://savage.net.au/Perl-modules/html/marpa.papers/null.lexeme.demo.p.l.txt">null.lexeme.demo.pl</a> and
<a href="http://savage.net.au/Perl-modules/html/marpa.papers/null.lexeme.demo.1.p.l.txt">null.lexeme.demo.1.pl</a>.</p>

<p><a name = 'q119'></a></p>

<h2>119 How do I find out where I am within the input stream?</h2>

<p>See <a href="https://metacpan.org/module/Marpa::R2::Scanless::R#line_column">the line_column() method in Marpa::R2::Scanless::R</a>.</p>

<p><a name = 'q120'></a></p>

<h2>120 How do I find out which rule applies at some point in the input stream (e.g. during a pause)?</h2>

<p>See under <a href="https://metacpan.org/module/Marpa::R2::Semantics#Action-context">Action-context in Marpa::R2::Semantics</a>,
for access to internal variables in Marpa which do what you want.</p>

<p><a name = 'q121'></a></p>

<h2>121 What is the meaning of the line number in a Marpa error message?</h2>

<p>It is the line number within the BNF of the rule being processed.</p>

<p>Note: If your grammar uses \r, that will affect the line count.</p>

<p>Further, see <a href="https://metacpan.org/module/Marpa::R2::Scanless::R#line_column">the line_column() method in Marpa::R2::Scanless::R</a>
for various special characters some of which may affect this line count.</p>

<p><a name = 'q122'></a></p>

<h2>122 Can I switch grammars during a parse?</h2>

<p>No - You can't just change Marpa's grammar object during a parse (by calling
Marpa::R2::Scanless::G -> new() with a new BNF), and expect everything else to keep working.</p>

<p>Nevertheless, there are techniques which can probably do what you want.</p>

<ul>
<li><p>1: Combine the grammars</p></li>
<li><p>2: Use 'parse before' and switch grammars twice</p></li>
<li><p>3: Use an action, change the grammar, and re-parse</p></li>
</ul>

<p>In a bit more detail:</p>

<p>1: 'Combine the grammars': Perhaps you are convinced this can't be done, but you are urged to try
it. Focus on the problem of defining the lexemes.</p>

<p>You may find your solution involves switching lexers rather than switching grammars.</p>

<p>2: 'Use parse before and switch grammars twice': This technique is used in
<a href="https://metacpan.org/module/GraphViz2::Marpa">GraphViz2::Marpa</a>.</p>

<p>The idea is to pause at the start of a substring you want to parse using a different grammar. Then,
parse just that substring using a different grammar object and a different recognizer object.</p>

<p>At the end of the substring, tell the first grammar to resume at the first character after the end
of the substring.</p>

<p>This works in my (Ron's) code because the second grammar ends with a known, matching, delimiter.
When Marpa encounters the next character, it generates the infamous error: 'Parsing complete
but lexemes remain'. Luckily for me, this just means there is (and there must be) tokens in the
input stream after the end of the substring which needed to be parsed using the second grammar. So
it's just a matter of asking Marpa if that particular error arose, processing the output from using
the second grammar, and returning to the parse which is using first grammar.</p>

<p>In the code referenced, search for '$self -> grammar' and '$self -> grammar4html'.</p>

<p>Your problem will obviously be: What happens at the end of the substring? I.e. How do you know it's
time to switch back to the previous grammar?</p>

<p>Also, this approach creates the problem of having the semantics defined in 2 different places. So
combining them may add complexity to your code.</p>

<p>3: 'Use an action, change the grammar, and re-parse': This technique is used in
<a href="https://github.com/jddurand/MarpaX-Languages-SQL2003-AST/blob/master/lib/MarpaX/Languages/SQL2003/AST/Actions.pm">MarpaX::Languages::SQL2003::AST</a>.</p>

<p>See <a href="http://irclog.perlgeek.de/marpa/2014-12-12#i_9797844">this IRC backlog entry</a> for a discussion
by the author, Jean-Damien Durand, for why he does things this way.</p>

<p>Briefly, the parse of a substring (call it 'a') requires knowledge of what follows that substring
(call the second substring 'b'). So, parse it all ('a + b'), and when the action is triggered for
'b', use the information found to change the grammar used to parse 'a', and re-parse 'a'.</p>

<p>The effect (in Jean-Damien's case at least) is to use the result of a sub-grammar as a token value.</p>

<p>You may safely assume this latter method is a very advanced technique!</p>

<p><a name = 'q123'></a></p>

<h2>123 Where is Ruby Slippers parsing documented?</h2>

<p>Start with <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#terminals_expected">Marpa::R2::Scanless::R's terminals_expected()</a>.
This document has several references to Ruby Slippers.</p>

<p>See also Jeffrey's articles: <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2011/11/marpa-and-the-ruby-slippers.html">Ruby Slippers parsing</a>,
and the series beginning with <a href="https://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2011/11/how-to-parse-html.html">parsing HTML part 1</a>.</p>

<p><a name = 'q124'></a></p>

<h2>124 Where can I find code using Ruby Slippers?</h2>

<p>See the script scripts/match.parentheses.02.pl, which ships with the module
<a href="https://metacpan.org/module/MarpaX::Demo::SampleScripts">MarpaX::Demo::SampleScripts</a>.</p>

<p><a name = 'q125'></a></p>

<h2>125 How do I associate an action class with my grammar?</h2>

<p>This discussion assumes you're using Marpa::R2 V 3.0 or later. Prior to that, there was complications
using the per-parse parameter to value(), and elsewhere.</p>

<p>See also <a href='#q126'>Q126 Declaring an Action Class</a> and
<a href='#q136'>Q136 How does Marpa pass parameters to action subs?</a>.</p>

<p>References:</p>

<p>1: <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod#The-per-parse-argument">The per-parse argument to value()</a></p>

<p>2: <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics.pod#The-per-parse-constructor">The per-parse constructor</a></p>

<p>3: <a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#value">Calling value(...)</a></p>

<p>Here's how I declare a recognizer in one package:</p>

<pre class="prettyprint linenums"><code>use MarpaX::Languages::SVG::Parser::Actions;

# And later...

$self -&gt; recce
(
    Marpa::R2::Scanless::R -&gt; new
    ({
        grammar           =&gt; $self -&gt; grammar,
        semantics_package =&gt; 'MarpaX::Languages::SVG::Parser::Actions',
    })
);
</code></pre>

<p>Now actions referenced in the grammar, as in:</p>

<pre class="prettyprint linenums"><code>coordinate  ::= float      action =&gt; float
                | integer  action =&gt; integer
</code></pre>

<p>must be declared as functions in the named semantics package, because that's where Marpa looks for them.</p>

<p><a name = 'q126'></a></p>

<h2>126 Declaring an Action Class</h2>

<p>Firstly, see also <a href='#q136'>Q136 on how Marpa passes parameters to action subs</a>.</p>

<p>Now, the previous item in this FAQ discussed at length various issues regarding how to cleanly generate data within action
subs, and how to pass that data back to the main-line code which called Marpa.</p>

<p>Here I explain the standard solution as used in a module,
<a href="https://metacpan.org/release/MarpaX-Languages-SVG-Parser">MarpaX::Languages::SVG::Parser</a>, on CPAN. Briefly:</p>

<ul>
<li>Each action sub returns a <em>hashref</em> to Marpa</li>
</ul>

<p>This is because Marpa is the one calling the subs and gathering the results. And the hashrefs of course suit my code,
whereas you may prefer to use a different data structure.</p>

<ul>
<li>After a successful parse, the result of the parse is processed to recover those hashrefs</li>
</ul>

<p>This result is returned by the value() method of the recognizer class.
See <a href="https://metacpan.org/module/Marpa::R2::Scanless::R#value">value() in Marpa::R2::Scanless::R</a>.</p>

<p>There is one basic problem to solve along the way: The data structure Marpa makes available as the result of the parse
can be a deeply nested set of <em>arrayrefs</em>, depending on how deeply within the grammar the action sub is named.</p>

<p>So, we have to unravel the <em>arrayrefs</em> to recover the <em>hashrefs</em>.</p>

<p>Conside this fragment of the SVG grammar from
<a href="https://metacpan.org/release/MarpaX-Languages-SVG-Parser">MarpaX::Languages::SVG::Parser</a>:</p>

<pre class="prettyprint linenums"><code>curve_to            ::= Cc curve_to_arguments  action =&gt; command

curve_to_arguments  ::= coordinate_triple
                        | coordinate_triple curve_to_arguments
...
coordinate_triple   ::= coordinate coordinate coordinate
...
coordinate          ::= float  action =&gt; float
...
Cc                  ~ [Cc]
</code></pre>

<p>Thus, given a curve - say the string 'C 10,11 20,21 30,31' - Marpa will call both <em>float()</em> and <em>command()</em>.</p>

<p>(Elsewhere the grammar says commas are to be discarded).</p>

<p>What happens in practice? Firstly, the code:</p>

<pre class="prettyprint linenums"><code>sub command
{
    my($hashref, $t1, @t2) = @_;
    $param_count = 0;

    return
    {
        count =&gt; ++$item_count,
        name  =&gt; $t1,
        type  =&gt; 'command',
        value =&gt; [@t2],
    };

} # End of command.

# -----------------

sub float
{
    my($hashref, $t1) = @_;

    return
    {
        count =&gt; ++$item_count,
        name  =&gt; ++$param_count,
        type  =&gt; 'float',
        value =&gt; $t1,
    };

} # End of float.
</code></pre>

<p>Things to note:</p>

<ul>
<li>We don't count the floats, to ensure there are 6, or 8, ...</li>
</ul>

<p>This is because the input stream is deemed to have been validatated as being SVG.</p>

<ul>
<li><p>A global variable counts output hashrefs</p></li>
<li><p>A global variable counts parameters per command</p></li>
<li><p><em>float()</em> is called for every number</p></li>
</ul>

<p>This includes the fact that the grammar says there are at least 3 coordinates (float pairs) per <em>curve</em> command.</p>

<p>This is not a problem, just a fact. We handle it with a Perl array, as explained next.</p>

<ul>
<li><em>command()</em> is called at the end of the string</li>
</ul>

<p>Again, this is not a problem. On the contrary - it is an inescapable part of the solution!</p>

<p>But it does mean that we need to be aware of what Marpa does with the results of calling <em>float()</em>, i.e. where
are they, when Marpa calls <em>command()</em>.</p>

<p>It is simple. The results of the 6+ (in this grammar) calls to <em>float()</em>, 6+ <em>hashrefs</em>, are passed as the trailing
parameters in the call to   <em>command()</em>. That explains the @t2 parameter in the first line of <em>command()</em>.</p>

<p>Likewise, we can say that since, in the grammar, nothing is subservient to <em>float</em>, then no action subs can possibly
be called in the processing of a float. So, when <em>float()</em> is called, it <em>cannot have</em> any such trailing parameters.</p>

<p>Where does this leave us? It means that the @t2 parameter to <em>command()</em> contains a set of 6+ floats packaged as
<em>hahsrefs</em> inside an unknown number of <em>arrayrefs</em>.</p>

<p>The same logic applies to the output of <em>command()</em> within the context of the output of parsing the whole input stream.</p>

<p>Our final task then will be to recover the result of the parse and unravel and discard the <em>arrayrefs</em>. This will
leave us with a set of <em>hashrefs</em>, which was the point of the exercise. I should repeat: This structure suits my
purpose. Adapt as required.</p>

<p>The remainder of the code:</p>

<pre class="prettyprint linenums"><code>my($result) = $self -&gt; recce -&gt; value;

die "Marpa's parse failed\n" if (! defined $result);

# Unravel whatever Marpa gives us.

for my $item (@{$self -&gt; decode_result($$result)})
{
    # If it's a command, unravel the 'value =&gt; [@t2]' component.

    if ($$item{type} eq 'command')
    {
        $self -&gt; new_item($$item{type}, $$item{name}, '-');

        for my $param (@{$self -&gt; decode_result($$item{value})})
        {
            $self -&gt; new_item($$param{type}, $$param{name}, $$param{value});
        }
    }
    else
    {
        $self -&gt; new_item($$item{type}, $$item{name}, $$item{value});
    }
}
</code></pre>

<p>Lastly, the workhorse sub:</p>

<pre class="prettyprint linenums"><code>sub decode_result
{
    my($self, $result) = @_;
    my(@worklist) = $result;

    my($obj);
    my($ref_type);
    my(@stack);

    do
    {
        $obj      = shift @worklist;
        $ref_type = ref $obj;

        if ($ref_type eq 'ARRAY')
        {
            unshift @worklist, @$obj; # Unravel Marpa's handiwork.
        }
        elsif ($ref_type eq 'HASH')
        {
            push @stack, {%$obj}; # Build array of results.
        }
        else
        {
            die "Unsupported object type $ref_type\n" if ($ref_type);
        }
    } while (@worklist);

    return [@stack]; # Return an arrayref of hashrefs.

} # End of decode_result.
</code></pre>

<p>I must acknowledge the work done by the authors of <a href="https://metacpan.org/release/Data-Find">Data::Find</a>,
<a href="https://metacpan.org/release/Data-Recursive-Encode">Data::Recursive::Encode</a> and
<a href="https://metacpan.org/release/MarpaX-Languages-C-AST" title="In *::Util::Data::Find">MarpaX::Languages::C::AST</a>.
They all use similar mechanisms for unravelling data structures.</p>

<p><a name = 'q127'></a></p>

<h2>127 Where can I find code using events?</h2>

<p>The are many Perl modules which use events.</p>

<p>Try <a href="https://metacpan.org/release/MarpaX-Languages-Perl-PackUnpack">MarpaX::Languages::Perl::PackUnpack</a>
or <a href="https://metacpan.org/release/GraphViz2-Marpa">GraphViz2::Marpa</a>.</p>

<p><a name = 'q128'></a></p>

<h2>128 Where can I find code which builds its grammar on-the-fly?</h2>

<p>A simple case: <a href="https://metacpan.org/release/Text-Balanced-Marpa">Text::Balanced::Marpa</a>.</p>

<p>A complex case: <a href="https://metacpan.org/release/MarpaX-Languages-SQL2003-AST">MarpaX::Languages::SQL2003::AST</a>.</p>

<p><a name = 'q129'></a></p>

<h2>129 Other Resources</h2>

<ul>
<li><p>http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html</p></li>
<li><p>The list of features in <a href="http://savage.net.au/Perl-modules/html/marpa.papers/chapter2.html">Chapter 2 - Marpa's Advantages</a></p></li>
</ul>

<p><a name = 'q130'></a></p>

<h2>130 Papers on Parsing Theory</h2>

<p><a href="http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/">Aria's list</a>.</p>

<p><a name = 'q131'></a></p>

<h2>131 Are there C/Perl/Rust/etc bindings for libmarpa?</h2>

<p>The original bindings are
<a href="https://github.com/jeffreykegler/libmarpa">Libmarpa, a C library</a>,
and
<a href="https://metacpan.org/pod/Marpa::R2">Marpa::R2, a Perl module</a>.
Marpa::R2 has been in stable release for many years,
and is based on Libmarpa.</p>

<p>A <a href="https://github.com/jrobsonchase/marpa">Rust wrapper</a> exists
which has proved useful in development.
It is
<a href="https://crates.io/crates/marpa/">also available as a crate</a>.</p>

<p>Other bindings are being prototyped,
or are in early development.</p>

<p><a name = 'q132'></a></p>

<h2>132 What are the Marpa Papers?</h2>

<p><a href="http://savage.net.au/Perl-modules/html/marpa.papers/">They are a small book of Marpa-related matters</a>,
and are highly recommended reading for (a) Getting Started, (b) Marpa's Advantages, and
(c) Advanced Usage.</p>

<p><a name = 'q133'></a></p>

<h2>133 What grammar do I use when eol ("\n", new-line) is significant?</h2>

<p>There is no definitive answer to this, because different contexts will have different interpretations
of how they need to handle eol.</p>

<p>It would be nice, however, to have some specific samples of grammar available.</p>

<p><a name = 'q134'></a></p>

<h2>134 When I use the case-insensitive suffix ':i' my program dies</h2>

<p>This is probably because you're using actions on rules, and you changed a lexeme from, say, "and ~ 'and'"
to "and ~ 'and':i". After you add the ':i', the parameter passed in to your action function will have an
extra arrayref around it, compared to what is was without the ':i'. Just dereference it with $t1 = $$t1[0].</p>

<p><a name = 'q135'></a></p>

<h2>135 When do I use actions and when do I use events?</h2>

<p>Actions are attached to rules, so when an action is fired, you know exaclty which rule is being triggered
by the 'current' text. And the data structure Marpa passes to your action sub contains the results of
that rule's subordinate rules, down to the lexeme level.</p>

<p>With events attached to lexemes, you know the lexeme but not the rule. Of course you can interrogate Marpa
about which rule is currently firing. For that, see <a href='#q18'>Q18</a>.</p>

<p>This choice is yet one more way in which Marpa differs so hugely from traditional parsers.</p>

<p>Also, see <a href="http://savage.net.au/Ron/html/Understanding.Marpa-style.action.subs.parameters.html">this article</a>
for an explanation of how Marpa passes parameters into action subs.</p>

<p><a name = 'q136'></a></p>

<h2>136 How does Marpa pass parameters to action subs?</h2>

<p>See this stand-alone article: <a href="http://savage.net.au/Ron/html/Understanding.Marpa-style.action.subs.parameters.html">How Marpa passes arguments to your action subs</a>.</p>

<p>See also <a name = 'q125'>Q125 How do I associate an action class with my grammar?</a> and
<a name = 'q126'>Q126 Declaring an Action Class</a>, and
<a name = 'q134'>Q134 When I use the case-insensitive suffix ':i' my program dies</a>.</p>

<p><a name = 'q137'></a></p>

<h2>137 SPPF parsing</h2>

<p>Marpa uses SPPF parsing, but not under that name. Jeffrey Kegler calls his version a 'parse bocage',
which he invented independently of Elizabeth Scott.</p>

<p>For details of her work, <a href="http://dinhe.net/~aredridel/.notmine/PDFs/Parsing/SCOTT,%20Elizabeth%20-%20SPPF-Style%20Parsing%20From%20Earley%20Recognizers.pdf">see here</a>.</p>

<p><a name = 'q138'></a></p>

<h2>138 Parse exhaustion</h2>

<p><a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Exhaustion.pod">See</a>, and
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#exhaustion">this setting</a>.</p>

<p><a name = 'q139'></a></p>

<h2>139 What is the difference between prediction events and pre-lexeme events?</h2>

<p>A prediction event will be triggered when its lexeme is predicted (i.e. expected) at some point in
the input stream. A pre-lexeme event can only be triggered at the start of a lexeme which has been
explicitly detected in the input stream.</p>

<p><a name = 'q140'></a></p>

<h2>140 Precedence, associativity, priority and rank</h2>

<p>This answer was added after a discussion on IRC,
<a href="http://irclog.perlgeek.de/marpa/2016-05-22#i_12725635">starting here</a>.</p>

<p>Try tackling these 4 issues in this order:</p>

<ul>
<li>Re-write the grammer</li>
</ul>

<p>Yes, seriously.</p>

<p>Keep this in mind: Lexeme priority only works if the lexemes are exactly the same length, and start
at the same location. This is a limitation in R2 which will be lifted in R3.</p>

<ul>
<li><p>Consider using Marpa's 'priority' adverb, discussed
<a href="https://metacpan.org/pod/Marpa::R2::Scanless::DSL#priority">here</a>, and its 'rank' adverb, discussed
<a href="https://metacpan.org/pod/Marpa::R2::Scanless::DSL#rank">here</a>.</p></li>
<li><p>Observe that there is another way of
<a href="https://metacpan.org/pod/Marpa::R2::Scanless::DSL#Prioritized-rule">prioritizing rules, using '|' versus '||'</a>.</p></li>
<li><p>Lastly, parse order can be influenced by
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Semantics/Order.pod#The-rule-ranking-method">rule ranking</a>.</p></li>
</ul>

<p><a name = 'q141'></a></p>

<h2>141 I want to write my own version of the Marpa/Earley/Leo algorithm in language X. What's the best way to proceed?</h2>

<p>This is Jeffrey speaking: You'll probably want to work your way through many of my
<a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/metapages/annotated.html">blog posts</a>, especially this one:
<a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2011/11/what-is-the-marpa-algorithm.html">The Marpa Algorithm</a>.</p>

<p>Experience suggests writing the parser in this order:</p>

<ul>
<li><p>A basic Earley's parser.</p></li>
<li><p>The Aycock &amp; Horspool grammar rewrite, to fix issues with nulls.</p></li>
<li><p>Joop Leo's improvement.</p></li>
<li><p><a href='#q137'>Elizabeth Scott's SPPF</a>, or some other binarization of the output.</p></li>
</ul>

<p>Marpa was not actually developed in this order --
it would have been much easier if it had been.</p>

<p><em>The Aycock &amp; Horspool fix for null terminals</em>:
Null terminals and rules were a nasty and persistent problem with Earley's until A&amp;H found the
fix.</p>

<p><em>Joop Leo's improvement</em>:
This is hard but necessary if you want to avoid having your parser being regarded as second class.
Leo improved Earley's algorithm to be linear for all deterministic context-free grammars, which is
a big, big deal. Without Leo's improvement, for example, your parser won't really be able to
handle true second-order languages -- languages which are the output of other programs, including
languages produced as the output of other languages.</p>

<p><em>The Marpa ordering</em>:
The Marpa algorithm takes pains to have the parse engine complete all work in one Earley set
before doing any work in the next one. This allows the parser to do better debugging; to use
advanced methods like the Ruby Slippers; to be used on an event-driven basis; and to be paired
with custom procedural logic.</p>

<p><em>Earley hacks you may want to skip</em>:
Many of the other improvements IMHO you will want to skip, including the LR(0) states in the
Aycock &amp; Horspool paper. In general, I suggest you be skeptical of those improvements which do
not produce better results in big-O terms, but instead merely reduce the number of Earley items
by a constant amount. These do not seem to produced measurable speed-ups at parsing time, but
they must be undone at evaluation time. They will make it very hard to add an event mechanism to
your parser, and will make debugging and tracing more complex.</p>

<p><a name = 'q142'></a></p>

<h2>142 I used a precedenced statement for my expression, so why did my parse come out ambiguous anyway?</h2>

<p>There is a section in the Marpa::R2 documents that
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/DSL.pod#Precedence-and-ambiguous-grammars">deals specifically with this</a>.</p>

<p>But that section contains no examples. So here is one. Let your input be:</p>

<p>1 2 + 3 4</p>

<p>Consider this precedenced statement:</p>

<p>E ::= Number || E E || E '+' E</p>

<p>The parse is unambiguous. Here is the only parse:</p>

<p>((1,2),+,(3,4))</p>

<p>But suppose we change the grammar to add unary plus, so that the precedenced statement is now:</p>

<p>E ::= Number || '+' E || E E || E '+' E</p>

<p>Now the parse is ambiguous -- these are the two parses:</p>

<p>(((1,2),(+,3)),4) and ((1,2),+,(3,4))</p>

<p>Notice that both of these parses obey precedence. Precedence can be
seen as removing ambiguity, but it does not remove <em>all</em> ambiguity.
It only eliminates those parses which do not obey the precedence.</p>

<p><a name = 'q143'></a></p>

<h2>143 How do I contribute to this FAQ?</h2>

<p>The FAQ is on github. Just <a href="https://github.com/ronsavage/marpa.faq">raise an issue</a>. If you're not familiar
with github, just click on '(!) Issues 0'. The 0 is the # of open issues, so it may be > 0.</p>

<p><a name = 'q144'></a></p>

<h2>144 How do I use external parsing?</h2>

<p>External parsing is where you write your own code to do some parsing, while getting Marpa to handle various
parts of the work.</p>

<p>One advantage of exernal parsing is that you can employ the full power of Perl's regexp capabilities, allowing
you to thereby do more than is built into Marpa's SLIF (Scanless Interface aka BNF).</p>

<p>Note that you can switch back and forth between letting Marpa do the parsing and doing some of it yourself.</p>

<p>So why not do all of it one way or t'other? The obstacle is that Perl regexes are deterministic, while Marpa is
non-deterministic.</p>

<p><a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#External-scanning">See 'External scanning'</a>
for a discussion in the Marpa docs.</p>

<p>Jeffrey has blogged about it <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/04/procedural.html">here</a>
and <a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2013/06/mixing-procedural.html">here</a>.</p>

<p>rns has a <a href="https://gist.github.com/rns/d19b40ffc5523659dec9">gist</a> demonstrating such code. Note specifically
the 'for' loop starting at line 59. Your code jumps in and out of Marpa based on the event declared on line 36.</p>

<p>In brief, when Marpa detects input matching whatever you have attached an event to, it (Marpa) exits and your
code - within the loop - takes over. Normally the first step is to ask Marpa which events triggered the exit.
And yes, that was 'events' plural since several events can be triggered simultaneously at the same place in
the input stream.</p>

<p>Ron Savage uses this technique in a number of modules:</p>

<ul>
<li><p><a href="https://metacpan.org/release/GraphViz2-Marpa">GraphViz2::Marpa</a></p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Demo-SampleScripts">MarpaX::Demo::SampleScripts</a></p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Languages-Dash">MarpaX::Languages::Dash</a></p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Grammar-GraphViz2">MarpaX::Grammar::GraphViz2</a></p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Grammar-Parser">MarpaX::Grammar::Parser</a> (Although I did not write all the BNF!)</p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Languages-Lua-Parser">MarpaX::Languages::Lua::Parser</a>
(For which Jeffrey wrote the BNF and I packaged it)</p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Languages-Perl-PackUnpack">MarpaX::Languages::Perl::PackUnpack</a></p></li>
<li><p><a href="https://metacpan.org/release/MarpaX-Languages-SVG-Parser">MarpaX::Languages::SVG::Parser</a></p></li>
<li><p><a href="https://metacpan.org/release/Regexp-Parsertron">Regexp::Parsertron</a></p></li>
<li><p><a href="https://metacpan.org/release/Text-Balanced-Marpa">Text::Balanced::Marpa</a></p></li>
<li><p><a href="https://metacpan.org/release/Text-Delimited-Marpa">Text::Delimited::Marpa</a></p></li>
</ul>

<p>See also the next question.</p>

<p><a name = 'q145'></a></p>

<h2>145 How do I distinguish between identifiers and keywords?</h2>

<p>A good way is to use lexeme priorities, perhaps by combining them with external parsing.</p>

<p>See the previous question for sample code.</p>

<p>Jean-Damien Durand has written several full language parsers, including one for
<a href="https://github.com/jddurand/MarpaX-Languages-ECMAScript-AST">ECMAScript</a>.</p>

<p>More sample code is in <a href="http://stackoverflow.com/questions/27109840/marpa-can-i-explicitly-disallow-keywords-as-identifiers">this article</a>
on Stackoverflow.</p>

<p><a name = 'q146'></a></p>

<h2>146 How do I write the BNF to specify exceptions to a pattern, or the complement of a pattern?</h2>

<p>Currently there is no way to specify that directly in Marpa::R2, because context free grammars (CFGs) are not closed
under complement. That is: If L1 and L2 are both BNF grammars, it is not necessarily possible to write L1 - L2 in BNF.</p>

<p>Nevertheless, Jean-Damien Durand has done something similar with this C implementation of a wrapper around Marpa,
which uses his version of BNF. See:</p>

<ul>
<li><p><a href="https://github.com/jddurand/c-marpaWrapper#marpawrapperasfvalue_valueb">The C implementation is documented here</a>.</p></li>
<li><p><a href="https://github.com/jddurand/c-marpaESLIF/tree/master/doc/BNF">The version of BNF defined for his project</a>.</p></li>
<li><p><a href="https://github.com/jddurand/c-marpaESLIF">And the github repository</a>.</p></li>
</ul>

<p>This approach consists of building an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">ASF - Abstract Syntax Forest</a>
of parse results and then processing the trees in that forest.</p>

<p><a name = 'q147'></a></p>

<h2>147 How do I write the BNF when the first token is optional?</h2>

<p>Note: <a href="https://metacpan.org/release/GraphViz2-Marpa">GraphViz2::Marpa</a> requires this technique, since it's working
from <a href="http://www.graphviz.org/content/dot-language">this BNF</a>.</p>

<p>Make sure you use enough tokens in your BNF. Do not try to compress the BNF when dealing with this issue.</p>

<p><a href="https://metacpan.org/source/RSAVAGE/GraphViz2-Marpa-2.11/lib/GraphViz2/Marpa.pm#L217">Sample code</a>.</p>

<p><a name = 'q148'></a></p>

<h2>148 Is there a tabular view of the DSL?</h2>

<p>Yes: <a href="http://savage.net.au/Marpa/html/Marpa.R2.DSL.Structure.html">A Tabular View of Marpa::R2's DSL</a>.</p>

<p><a name = 'q149'></a></p>

<h2>149 The Libmarpa API and missing valuator steps</h2>

<p>When working with libmarpa, if you notice things like missing instructions of types
MARPA_STEP_RULE and MARPA_STEP_NULLING_SYMBOL, make sure you are calling marpa_g_force_valued()
immediately upon grammar creation.</p>

<p>For details see <a href="https://groups.google.com/forum/#!msg/marpa-parser/JZzPXkuAMVU/lIUJpGgIAQAJ">this Marpa Google Group post</a>.</p>

<p><a name = 'q150'></a></p>

<h2>150 Are there any comparisons of Marpa against other parsers for speed and practicality?</h2>

<p>MarpaX::ESLIF is an optimized version of Marpa::R2.
<a href="https://colabti.org/irclogger/irclogger_log/marpa?date=2022-08-05">Its 2022 announcement on the Marpa IRC channel</a>
discusses their relative speeds.</p>

<p>Jeffrey Kegler and Terence Parr (author of ANTLR) had
<a href="https://www.reddit.com/r/programming/comments/2g1mww/the_marpa_parser/ckhl9ws/">a brief exchange on Reddit in 2014</a>.</p>

<p>Lars Dieckow (daxim) performed a "shootout"
among various parsers, including Perl 6, Marpa and ANTLR,
and reported his results in
<a href="https://youtu.be/lFBEf0o-4sY?si=ieaN2UZ6XhzTTdwz">a 2017 talk</a>.</p>

<p><a href="https://dl.acm.org/doi/pdf/10.1145/3360553">This paper</a>
describes both ANTLR and Marpa as "industrial grade"
and pits them against each other in a performance benchmark.
The paper is in the refereed literature and its
authors (Henriksen, Bilardi and Pingali) are independent of
the Marpa and ANTLR communities.</p>

<p><a name = 'q151'></a></p>

<h2>151 How can I trace what the L0 parser is doing?</h2>

<p>Use the trace_terminals parameter to
<a href="https://metacpan.org/pod/distribution/Marpa-R2/pod/Scanless/R.pod#trace_terminals">Marpa::R2::Scanless::R's constructor</a>.</p>

<p>See <a href="https://metacpan.org/source/RSAVAGE/GraphViz2-Marpa-2.11/lib/GraphViz2/Marpa.pm#L436">GraphViz2::Marpa's usage</a> for sample code.</p>

<p>trace_terminals takes values from 0 to 99, with higher numbers requesting more verbose output. Start with 1 and then
jump to 99.</p>

<p><a name = 'q152'></a></p>

<h2>152 How do I define lexemes for identifiers where the 1st char is from a subset of the other chars?</h2>

<p>Assume the identifier is something like $head$tail, where $head must belong to</p>

<pre class="prettyprint linenums"><code>[_A-Za-z]
</code></pre>

<p>but $tail is allowed to belong to</p>

<pre class="prettyprint linenums"><code>[_A-Za-z0-9]*
</code></pre>

<p>meaning $tail may be empty or many chars long. Try this:</p>

<pre class="prettyprint linenums"><code>:lexeme            ~ capture_name  pause =&gt; before  event =&gt; capture_name
capture_name       ~ capture_name_head capture_name_tail
capture_name_head  ~ [_A-Za-z]

capture_name_tail  ~ [_A-Za-z0-9]*
</code></pre>

<p>And no, you do not need to use events. (I do, in Regexp::Parsertron :-).</p>

<p><a name = 'q153'></a></p>

<h2>153 Are there any on-line tools for testing grammars?</h2>

<p>Yes. See <a href="https://mdaines.github.io/grammophone/">Grammophone</a>. Also, specifically for testing LL,
see <a href="http://www.fit.vutbr.cz/~ikocman/llkptg/">this LL(k) tester</a>.</p>

<p><a name = 'q154'></a></p>

<h2>154 What do I do when the IRC logbot stops?</h2>

<p>Firstly, here is the logbot's <a href="http://colabti.org/irclogger/irclogger_log/marpa?date=2018-08-09">HTML report</a>.</p>

<p>To contact the admin, log on to irc.freenode.net's channel #irclogger and sent a message to 'feb'.</p>

<p><a name = 'q155'></a></p>

<h2>155 Where can I find a timeline (history) of parsing?</h2>

<p>See <a href="https://jeffreykegler.github.io/personal/timeline_v3">Jeffrey Kegler's timeline</a>.</p>
        </div>
    </div>
    <div class="row footer">
        <div class="offset2 span8">
            <p>
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="float:left; margin-right:12px; border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">The Marpa FAQ</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Ron Savage and Contributors</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a> and the <a rel="license" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3</a></p>
        </div>
    </div>
</div>
<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
</body></html>
